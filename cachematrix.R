## This R Script contains two functions.
## The purpose of this script is to determine inverse of a matrix and cache it, so that subsequent calls to determine inverse 
## for the same matrix, will just fetch it from cache instead of re-deriving it. This is done as inverse is a memory intesive process.

## Key assumption - The matrix supplied is always invertible. Script will fail if non-invertible matrix is input.

## makeCacheMatrix - This function basically accepts a matrix and will return a special vector which is list of functions
## This list will cache the Matrix inverse when its derived for the first time, subsequent inverse request for the same matrix
## will will fetch if from cache.

#function taken a matrix as input, the input matrix is assigned to variable x, whose
#scope is confined to environment of function makeCacheMatrix
makeCacheMatrix <- function(x = matrix()) 
{

#matrixInverse Local variable to function makeCacheMatrix, initilized to NULL
  matrixInverse <- NULL
  
#Function setMatrix assigns its input matrix (y) to input matrix (argument x) of function makeCacheMatrix
# <<- supperassignment operator lets one make this cross environment assignment. 
#This function allows you to change previously input matrix. This function also sets 
#matrixInverse to NULL, thus resetting it just in case it was already calculated.
  setMatrix <- function(y) 
      {
          x <<- y
          matrixInverse <<- NULL
      }

#Function getMatrix returns the input matrix
  getMatrix <- function() 
      {
          x
      }

#Function setInverse assigns its argument (which is inverse) to matrixInverse variable of 
#function makeCacheMatrix
  setInverse <- function(inverse) 
      {
          matrixInverse <<- inverse
      }

#Function getInverse returns the inverse of the input matrx
  getInverse <- function() 
      {
          matrixInverse
      }

#a list is created which has the above 4 functions as components, function makeCacheMatrix
#returns this list
		  list(setMatrix = setMatrix, getMatrix = getMatrix, setInverse = setInverse, getInverse = getInverse)
  
}



#Function cacheSolve takes list generated by function makeCacheMatrix, checks if Inverse is
#derived for the matrix in the list, if it is, then retrieves if from cache, if not derives it

#Argument x should be a list generated by function makeCacheMatrix, ... allows passing additional arguments to
#solve() function that we use to derive inverse of a matrix

cacheSolve <- function(x, ...) 
{

#This basically invokes the function getInverse() in list x, which return the inverse if its already calculated
#if not retuns null
  inverse <- x$getInverse()
  
#The if statement checks if the above statment returned NULL, if NOT NULL, then it implies inverse already computed
#and its available in cache, types appropriate message and returns the inverse, execution halts
  if(!is.null(inverse)) 
      {
          message("getting cached data")
          return(inverse)
      }

#If control has arrived to this step it means there is no inverse in cache, therefore the matrix is read into
# a variable data
          data <- x$getMatrix()

#the matrix is passed to function solve(), which determines the inverse of matrx.
# ... alows passing more arguments to solve like tol.LINKPACK etc
          inverse <- solve(data, ...)

#the inverse derived above is assigned to the cache
          x$setInverse(inverse)

#the inverse is returned for function of cacheSolve.
          inverse
}
